function h(state):
    num_enemy = get_num_enemy(state)
    state_cpy = copy(state)
    h_dist = 0
    for i from num_enemy-1 to 0:
        (PLAYER, ENEMY, dist) = closest_pair(state_cpy)
        h_dist += dist
        state_cpy: change ENEMY 'b' to PLAYER 'r'
    return h_dist


function A_star(state, root):
    discovered = init_min_heap()	// pq for discovered nodes, min-heap to check quickly if leaf > other leafs
    parents    = init_dict()		// the immediate parent of a current node
    g_cost     = init_dict()		// real cumulative cost from root
    f_cost     = init_dict()		// best guess f = g + h

    discovered.push(state)		// init state has now been discovered
    g_cost[root] = 0
    f_cost[root] = h(state, state)

    while discovered not empty:
        curr_state = discovered.push()
        if goal(curr_state):
            return reconstruct_path(parents, curr_state)

        for each dir in all_dir:			  // for each child node of current
            new_state = curr_state.copy()
            spread(root, dir, new_state)
            g_cost_accum = g_cost(curr_state) + 1 // true cost from init to new_state via curr_state

            if new_state not in g_cost or g_cost_accum < g_cost[new_state]:
                parent(new_state) = curr_state
                g_cost[new_state] = g_cost_accum
                f_cost[new_state] = g_cost_accum + h(new_state)
                if new_state not in discovered:
                    discovered.push(new_state)
                h(new_state)
    return NULL



A few things to keep track of:
    -  If x and y of opposite direction, then they're on the same vertical axis
    -  If 

